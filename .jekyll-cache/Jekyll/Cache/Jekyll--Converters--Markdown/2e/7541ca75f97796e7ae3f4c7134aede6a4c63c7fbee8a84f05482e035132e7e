I"h<p>There are words that we, well I, sometimes use with hesitation: we are not 100% sure about their meaning, especially when they are in a foreign language.</p>

<p>Puppet class <strong>indirection</strong> is one of these.</p>

<p>It’s the name I give to the pattern I’m going to describe in these lines, but I’m not fully sure that’s a correct one.</p>

<p>Anyway, I already happened to write about <a href="2016-05-30-exploring-puppet4-modules-design-patterns.md">class indirection</a> driven via Hiera, let’s review here the key principles and see some use case.</p>

<p>We are used, with Puppet, to include classes which contain other classes.</p>

<p>It happens in most of the modules, where the main class includes sub classes to manage installation, service, configuration or extra components of the managed application.</p>

<p>It may happen in our site profiles, where we group different kind of resources in different classes and we wrap then in a single handy wrapper class.</p>

<p>Class indirection is the possibility of defining what class to use of each of this sub function.</p>

<p>This can be simply accomplished by exposing in the main class (the ones that includes the other ones) parameters that define the names of the sub classes to include.</p>

<p>An example is from <a href="https://github.com/example42/psick">PSICK</a>, where there’s a baseline profile for each <strong>$::kernel</strong> which exposes a parameter to define the name of the class to use for each sub component / group of system’s resources.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class profile::base::linux (

  # General switch. If false nothing is done in this class.
  Boolean $enable,

  String $puppet_class,
  [...]
  String $ssh_class,

) {
  if $puppet_class != '' and $enable {
    contain $puppet_class
  }
  [...]
  if $ssh_class != '' and $enable {
    contain $ssh_class
  }
}
</code></pre></div></div>

<p>This means that it’s possible to define on Hiera the names of the classes to use to manage Puppet, SSH or anything else with data like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profile::base::linux::puppet_class: '::profile::puppet::agent'
profile::base::linux::ssh_class: '::profile::openssh'
</code></pre></div></div>

<p>Which, being Hiera driven, given us complete flexibility to manage common classification problems in handling exceptions and edge cases.</p>

<p>On a PuppetMaster role or node Hiera file, for example, we might have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profile::base::linux::puppet_class: '::profile::puppet::master'
</code></pre></div></div>

<p>on a SSH gateway or jump host we might have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profile::base::linux::ssh_class: '::profile::ssh::jump'
</code></pre></div></div>

<p>This approach makes it easier to test and rollout new profiles and manage a gradual puppettization of resources on a brown field environment.</p>

<p>For example when introducing management of ssh via Puppet on existing servers, we can disable on <code class="highlighter-rouge">common.yaml</code> to inclusion of any ssh class:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profile::base::linux::ssh_class: ''
</code></pre></div></div>

<p>and then to test our class on a <code class="highlighter-rouge">env/test.yaml</code> file with our profile:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profile::base::linux::ssh_class: '::profile::openssh'
</code></pre></div></div>

<p>And then eventually update <code class="highlighter-rouge">common.yaml</code> with the tested <code class="highlighter-rouge">'::profile::openssh'</code>.</p>

<p>Note that we don’t always need a custom profile to manage an application, an existing module may do all what we need. In such cases, we might include it directly:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profile::base::linux::ssh_class: '::openssh'
</code></pre></div></div>

<p>and use in Hiera parameters from the used module:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openssh::root_login: false
</code></pre></div></div>

<p>I found this pattern particularly fitting for baseline classes that typically include other classes, but it might be useful also in normal modules.</p>

<p>I’d love to see, as common practice, the usage of parameters like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class apache (
  String     $install_class = '::apache::install',
  String     $service_class = '::apache::service',
  String     $config_class = '::apache::config',
 ) { [...] }
</code></pre></div></div>

<p>Having the possibility to override the class used to manage, for example, the installation of Apache, would be make the module usable, without changes, in many environments with legacy needs (for example custom repos or packages). It’s up to the user to provide a working alternative class:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apache::install_class: '::profile::apache::install'
</code></pre></div></div>

<p>In other cases we might replace the classes that require external modules dependencies that conflict with ours with our own modified version, in a different namespace with the needed corrections.</p>

<p>These are just examples. Possibilities and use cases are many but most of all, class indirection is easy to introduce in a module and doesn’t harm.</p>

<p>To introduce is a matter of changing code like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ntp (
) {
  contain ntp::install
  contain ntp::config
  contain ntp::service
  Class['::ntp::install']
  -&gt; Class['::ntp::config']
  ~&gt; Class['::ntp::service']
}
</code></pre></div></div>

<p>to something like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ntp (
  String $install_class = '::ntp::install',
  String $config_class = '::ntp::config',
  String $service_class = '::ntp::service',
) {
  contain $install_class
  contain $config_class
  contain $service_class
  Class[$install_class]
  -&gt; Class[$config_class]
  ~&gt; Class[$service_class]
}
</code></pre></div></div>

<p>Will users ever use such parameters to provide their own classes? In many cases never, but adding them requires low efforts and makes the module more adaptable to special cases.</p>

<p>Alessandro Franceschi</p>
:ET