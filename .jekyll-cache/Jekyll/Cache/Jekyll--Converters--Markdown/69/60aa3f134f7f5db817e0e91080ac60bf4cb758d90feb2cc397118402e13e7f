I"u+<p>Whoever works with Puppet is probably familiar with facts.</p>

<p>In this series of posts we are going to review the different kind of facts we can deal with, when working with Puppet, hopefully clarifying grey zones or revealing new informations.</p>

<h3 id="facter-basics">Facter basics</h3>

<p>Whenever we install Puppet’s agent on a node, another tool, called <strong>Facter</strong> is installed.</p>

<p>Its task it to collect information about the system, <em>any</em> Operating System, and present them as <strong>facts</strong>.</p>

<p>We can run it from the command line and see the facts it collects on our system, it shows them in alphabetical order:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ facter

aio_agent_version =&gt; 5.3.2
[...]
timezone =&gt; CEST
virtual =&gt; virtualbox
</code></pre></div></div>

<p>Facter is executed at the beginning of every Puppet run and the collected facts are included in the catalog request by the Puppet agent to the Puppet server.</p>

<p>After receiving a client’s catalog request, the Puppet server does the following:</p>

<ul>
  <li>[Usually] stores the client’s facts on PuppetDB, so that they can be queried and <strong>visualised</strong> in some web frontend</li>
  <li>Uses the facts, together with our code and data, to compile the client’s catalog which is then sent back</li>
</ul>

<p>So the actual catalog applied during a Puppet run on the client, can be based on data coming from the client itself, collected as facts.</p>

<p>Facts are or can be used in a lot of places in our Puppet control-repo:</p>

<ul>
  <li>In public or local modules facts like <code class="highlighter-rouge">os, operatingsystem, osfamily, kernel...</code> are used to provide correct resource names (packages, paths, services…) and behaviour for different OS.</li>
  <li>Modules can provide custom facts, for example application’s version or anything needed for the managed resources</li>
  <li>In our profiles we may create and add custom facts used according to our needs</li>
  <li>In our Hiera’s hierarchy we often use facts, eventually custom ones, based on local topologies</li>
  <li>In our main manifests we may set global resource defaults or set top scope variables based on the values of facts</li>
  <li>In our main manifests we can manage nodes classification based on some local fact (<code class="highlighter-rouge">include "role::${role}"</code>)</li>
  <li>On web frontends like Puppet Enterprise Console, Foreman we may configure and classify nodes based on facts values</li>
  <li>Any web frontend able to access PuppetDB can have a function of an <strong>Inventory system</strong>, giving easy visibility to [semi] realtime, easily customisable, facts about the system</li>
  <li>Facter can be installed as standalone tool, without Puppet, and be integrated with 3rd party software, as system’s data collector (more suitable for relatively static informations than data series)</li>
</ul>

<p>We have different kind of facts:</p>

<ul>
  <li>
    <p><strong>Core</strong> facts are shipped with Facter itself, we can find them in any Puppet installation</p>
  </li>
  <li>
    <p><strong>Custom</strong> facts are written in Ruby and can be shipped in modules</p>
  </li>
  <li>
    <p><strong>External</strong> facts are simple text files or commands (in any language) which also can be shipped in modules</p>
  </li>
  <li>
    <p><strong>Trusted</strong> facts are extension requests added to Puppet’s client SSL certificates. They must be defined before the very first Puppet run and once set, can’t be changed (unless the client certificate is recreated and resigned)</p>
  </li>
</ul>

<p>Let’s start, in this post to review:</p>

<h3 id="core-facts">Core facts</h3>

<p>These are the typical and most common facts we deal with when using Puppet, they are shipped with Facter itself and, starting from Facter version 3 they are written in C++ and are much faster to generate.</p>

<p>Earlier Facter versions had facts written in Ruby with a structure and content similar to the one we can use in Custom facts (we will review them in the next post).</p>

<p>Starting from Facter 2, facts can have values different from simple strings, so <strong>structured facts</strong> have been introduced.</p>

<p>In Puppet 3 a neater distinction has been promoted:</p>
<ul>
  <li>New, mostly structured, <strong>modern facts</strong> are the recommended onesaas</li>
  <li>The, widely used, older <strong>legacy facts</strong> are still supported, but not visualised by default from the command line.</li>
</ul>

<p>So, for example, legagy facts, like <code class="highlighter-rouge">operatingsystem</code>, <code class="highlighter-rouge">osfamily</code>, <code class="highlighter-rouge">architecture</code> are now replaceable with subkeys of the modern, structured fact <code class="highlighter-rouge">os</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[vagrant@git ~]$ facter  os
{
  architecture =&gt; "x86_64",
  family =&gt; "RedHat",
  hardware =&gt; "x86_64",
  name =&gt; "CentOS",
  release =&gt; {
    full =&gt; "7.5.1804",
    major =&gt; "7",
    minor =&gt; "5"
  },
  selinux =&gt; {
    config_mode =&gt; "enforcing",
    config_policy =&gt; "targeted",
    current_mode =&gt; "enforcing",
    enabled =&gt; true,
    enforced =&gt; true,
    policy_version =&gt; "28"
  }
}
</code></pre></div></div>

<p>Being an hash, we can access the values of its subkeys as we normally do in Puppet code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class report_os {
  notice ("Operating system: ${::os['name']}")
  if $::os['family'] == 'RedHat'
  and has_key('os','selinux') {
    notice ("Selinux current mode ${::os['selinux']['current_mode']}")
  }
}
</code></pre></div></div>

<p>We have actually different ways to access to facts in Puppet code:</p>

<ul>
  <li>Referring directly to them: <code class="highlighter-rouge">$factname</code></li>
  <li>Using the <code class="highlighter-rouge">$facts</code> hash: <code class="highlighter-rouge">$facts[$factname]</code></li>
  <li>Using the <code class="highlighter-rouge">fact</code> function from stdlib module (which allows dotted notation and doesn’t fail if we try to access a non existing subkey): <code class="highlighter-rouge">fact($factname)</code>.</li>
</ul>

<p>So for example, the legacy fact <code class="highlighter-rouge">$osfamily</code> can be expressed also with any of these alternatives:</p>
<ul>
  <li>The relevant key in the structured fact os: <code class="highlighter-rouge">$os['osfamily']</code></li>
  <li>The relevant key and subkey in the facts hash: <code class="highlighter-rouge">$facts['os']['osfamily']</code></li>
  <li>The function fact with subkey expressed in dotted notation: <code class="highlighter-rouge">fact('os.osfamily')</code></li>
</ul>

<p>The most commonly used <strong>legacy facts</strong> are:</p>
<ul>
  <li><code class="highlighter-rouge">operatingsystem</code> ( same of <code class="highlighter-rouge">$::os['operatingsystem']</code> )</li>
  <li><code class="highlighter-rouge">osfamily</code> ( same of <code class="highlighter-rouge">$::os['family']</code> )</li>
  <li><code class="highlighter-rouge">operatingsystemrelease</code> ( same of <code class="highlighter-rouge">$::os['version']['full']</code> )</li>
  <li><code class="highlighter-rouge">architecture</code> ( same of <code class="highlighter-rouge">$::os['architecture']</code> )</li>
  <li><code class="highlighter-rouge">ipaddress</code> ( same of <code class="highlighter-rouge">$::networking['interfaces']["${::networking['primary']}"]['ip']</code> )</li>
  <li><code class="highlighter-rouge">fqdn</code> ( same of <code class="highlighter-rouge">$::networking['fqdn']</code> )</li>
  <li><code class="highlighter-rouge">hostname</code> ( same of <code class="highlighter-rouge">$::networking['hostname']</code> )</li>
  <li><code class="highlighter-rouge">domain</code> ( same of <code class="highlighter-rouge">$::networking['domain']</code> )</li>
</ul>

<p>The most interesting <strong>modern facts</strong>:</p>

<ul>
  <li><code class="highlighter-rouge">os</code>: Basic system info</li>
  <li><code class="highlighter-rouge">networking</code>: Networking info and status</li>
  <li><code class="highlighter-rouge">disks</code>: Disks layout</li>
  <li><code class="highlighter-rouge">filesystems</code>: Filesystems layout</li>
  <li><code class="highlighter-rouge">identity</code>: Info about the user running Facter</li>
  <li><code class="highlighter-rouge">memory</code>: Info about system memory</li>
  <li><code class="highlighter-rouge">processors</code>: Info about CPUs</li>
  <li><code class="highlighter-rouge">system_uptime</code>: Uptime, in various units</li>
  <li><code class="highlighter-rouge">ssh</code>: System’s ssh host public keys in various formats</li>
  <li><code class="highlighter-rouge">timezone</code>: The system’s timezone</li>
  <li><code class="highlighter-rouge">virtual</code>: Name of Hypervisor, or ‘physical’ for physical machines</li>
</ul>

<h4 id="digression-on-facts-and-local-class-variables">Digression on facts and local class variables</h4>

<p>All the facts are available as top scope variables when we refer to them in our code, so, for example, the <code class="highlighter-rouge">os</code> fact can be expressed with the <code class="highlighter-rouge">$::os</code> variable.</p>

<p>Note the leading <code class="highlighter-rouge">::</code> which ensures we are referring to a top scope variable called os. We can also use just <code class="highlighter-rouge">$os</code>, but doing so we are not sure if we refer to the os fact or a local class variable with the same name.</p>

<p>The better you give the idea, a code like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class test_fact {
  notice("\$::timezone is: ${::timezone}")
  notice("\$timezone is: ${timezone}")
  $timezone = 'Local change'
  notice("\$::timezone, after local override is still: ${::timezone}")
  notice("\$timezone, after local override is now: ${timezone}")
}
include test_fact
</code></pre></div></div>

<p>generates this output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Notice: Scope(Class[Test_fact]): $::timezone is: CEST
Notice: Scope(Class[Test_fact]): $timezone is still : CEST
Notice: Scope(Class[Test_fact]): $::timezone, after local override is still: CEST
Notice: Scope(Class[Test_fact]): $timezone, after local override is now: Local change
</code></pre></div></div>

<h3 id="conclusions">Conclusions</h3>

<p>In this first part of a a series of blog posts, we have seen the basic of Facter and its core facts, with particular emphasis on the difference between modern and legacy facts.</p>

<p>Next week we will start to see how we can create our own facts, customised to our needs.</p>

<p>Facts, not only words!</p>

<p>Alessandro Franceschi</p>
:ET