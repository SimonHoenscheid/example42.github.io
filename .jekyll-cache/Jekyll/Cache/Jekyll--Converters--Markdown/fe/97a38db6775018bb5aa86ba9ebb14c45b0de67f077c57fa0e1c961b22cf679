I"Œ;<p>In the first part of this blog series I expressed my opinions about these points:</p>

<ul>
  <li>The general reusability features a component module should have</li>
  <li>The difference between component and higher abstraction modules</li>
  <li>What are the challenges we have to face when we want to make reusable higher abstraction modules</li>
</ul>

<p>I also underlined two fundamental issues that I think are still open in the Puppet modules ecosystem:</p>

<ul>
  <li>Patterns to extend reusability of higher abstraction layer modules</li>
  <li>Standardization in the component application modules</li>
</ul>

<p>Some preliminary exploration on the first topic has been expressed in Part 1. There‚Äôs much more to do about it.</p>

<p>The second point is what we are going to discuss in this post.</p>

<p>In the last months there has been the effort to stimulate collaboration around a standard set of naming properties for modules parameters: the <a href="https://github.com/stdmod/">StdMod</a> initiative seems quite stale, it doesn‚Äôt seem to be a high priority for Puppet‚Äôs community.</p>

<p>Still I think that a coherent and standard set of class and defines parameters, would be of great benefit.</p>

<p>It sounds obvious, because it is obvious.</p>

<p>How many times we just need, from a module, to simply install its application and have the possibility to manage freely and easily its configuration?</p>

<p>How many times we had to write our own code for very simple needs because existing modules were too complex, or didn‚Äôt offer enough flexibility, or had dependency issues, or they forced us to study the module‚Äôs parameters in order to make them do what we wanted?</p>

<p>Modules that just install and configure a single application (what we are calling component modules) should just do that, in the simplest, quickest, and most predictable way.</p>

<p>During the years I wrote dozens of modules that had a standard interface: a common set of parameters that implemented basic reusability features, whose usage was easy  and predictable.
With a code like the following you could manage the ERB template of your application, whatever the module:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class { 'openssh:'
  template =&gt; 'site/openssh/sshd.conf.erb'
}
</code></pre></div></div>

<p>Most of Example42 modules, therefore, had a standard layout which was duplicated for each module. The horrible side of such an approach is that when I had to fix some ‚Äúcore‚Äù code, duplicated on all the modules, I had to do it on several places.
For example, most of the existing spec tests in Example42 modules are failing on Travis because they are not compliant with the latest versions of rspec-puppet. I should fix them, I don‚Äôt have enough time, will and motivation to do that.</p>

<p>So I wondered if it was possible to replicate the reusability and coherency features of these modules in a more manageable way.</p>

<h3 id="extreme-component-modules-standardization-tiny-puppet">Extreme component modules standardization: Tiny Puppet</h3>

<p>Well, it seems possible.</p>

<p>Here is <a href="https://github.com/example42/puppet-tp">TP (Tiny Puppet)</a>, if it will turn out as I hope, it will rock.</p>

<p>Consider Tiny Puppet as the essence of most of Example42 modules + some grains of Puppi.</p>

<p>It‚Äôs a single module that allows the installation and configuration of different component applications, using a set of common defines.</p>

<p>It‚Äôs supposed to be a replacement for simple application modules, when they just install and configure basic stuff, and a complementary tool for more complex modules, when they offer specific resources and options you may need.</p>

<p>The project is still at its very early stages, consider it as ReadMe driven development, various of the features which are described in the following lines have still to be developed or refined.</p>

<h4 id="installation-and-usage">Installation and usage</h4>

<p>Tiny Puppet is a normal module, you can install it by placing the content of the <a href="https://github.com/example42/puppet-tp">GitHub repository</a> in your modulepath. It will be published on the Forge, when it will be more complete and tested.</p>

<p>It depends on Puppet Labs‚Äôs stdlib module, and, optionally (if you use specific features) on the vcsrepo and concat modules.</p>

<p>It contains few basic defines that allow very specific functions:</p>

<ul>
  <li><code class="highlighter-rouge">tp::install</code>. It just installs an application and starts its service, with default settings</li>
  <li><code class="highlighter-rouge">tp::conf</code>. It allows to manage configuration files of an application with whatever method possible for files (as an ERB template, as an EPP template, via the fileserver, managing directly its content‚Ä¶)</li>
  <li><code class="highlighter-rouge">tp::dir</code>. Manages the content of a directory, either sourced from the fileserver or from repositories of the most common VCS tools (Git, Mercurial, Subversion, Bazaar, CVS)</li>
  <li><code class="highlighter-rouge">tp::stdmod</code>. Manages the installation of an application using StdMod compliant parameters.</li>
  <li><code class="highlighter-rouge">tp::line</code>. (TODO) Manages single lines in a configuration file</li>
  <li><code class="highlighter-rouge">tp::concat</code>. (TODO) Manages file fragments of a configuration file</li>
</ul>

<p>These are the basic tools, but they would be of relative use if they weren‚Äôt coupled with application specific data.</p>

<p>In the <code class="highlighter-rouge">data</code> directory of the tp module, for each supported application (currently very few, as I‚Äôm still defining the most optimal data structure and naming, but once this is defined it will be very quick to add support for new applications) there is a Hiera-like hierarchy of yaml files for different Operating Systems.</p>

<p>This data, which the user can always override, allow usage patterns like the one we see in the following paragraphs.</p>

<p>Worth noting is that the module is not invasive, it has limited dependencies and you can decide to use it only for the cases you need. For example you can use PuppetLabs PostgreSQL module‚Äôs types to manage grants and credentials and eventually use <code class="highlighter-rouge">tp::install</code> to install it and <code class="highlighter-rouge">tp::conf</code> to manage specific configuration files. Also, you can use a third party Apache module to install and configure it and <code class="highlighter-rouge">tp::dir</code> to manage the content of the documents root based on a VCS repository.</p>

<h4 id="tiny-puppet-usage-in-manifests">Tiny Puppet usage in manifests</h4>

<p>Her are some sample snippets of code that fulfil specific needs. They all refer to redis, as this is the frst application I used to test data structure, but are going to work for all the applications dfined in the data dir.</p>

<p>Install an application with default settings (package installed, service started)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::install { 'redis': }
</code></pre></div></div>

<p>Install an application specifying a custom dependency class (where, for example, you can add a custom package repository)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::install { 'redis':
  dependency_class =&gt; 'site::redis::redis_dependency',
}
</code></pre></div></div>

<p>Install custom packages:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::install { 'redis':
  packages =&gt; {
    'redis' =&gt; { 'ensure' =&gt; 'present' }
    'redis-addons' =&gt; { 'ensure' =&gt; 'present' }
  },
}
</code></pre></div></div>

<p>Install custom packages, services and files ( The parameters feed a create_resource function, so they might be populated from a Hiera call ):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::install { 'redis':
  packages =&gt; hiera('redis::packages'),
  service  =&gt; hiera('redis::services'),
  files    =&gt; hiera('redis::files'),
}
</code></pre></div></div>

<p>Configure a file of an application providing a custom erb template:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::conf { 'redis::redis.conf':
  template    =&gt; 'site/redis/redis.conf.erb',
}
</code></pre></div></div>

<p>Configure a file of an application providing a custom epp template:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::conf { 'redis::redis.conf':
  epp   =&gt; 'site/redis/redis.conf.epp',
}
</code></pre></div></div>

<p>Provide a file via the fileserver:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::conf { 'redis::redis.conf':
  source      =&gt; 'puppet:///modules/site/redis/redis.conf',
}
</code></pre></div></div>

<p>Provide a whole configuration directory from the fileserver:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::dir { 'redis':
  source      =&gt; 'puppet:///modules/site/redis/',
}
</code></pre></div></div>

<p>Provide a whole configuration directory from a Git repository (it requires Puppet Labs‚Äô vcsrepo module):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::dir { 'redis':
  source      =&gt; 'https://git.example.42/puppet/redis/conf',
  vcsrepo     =&gt; 'git',
}
</code></pre></div></div>

<p>Populate any custom directory from a Subversion repository (it requires Puppet Labs‚Äô vcsrepo module):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::dir { 'logstash': # The title is irrelevant, when 'path' is defined 
  path        =&gt; '/opt/apps/my_app',
  source      =&gt; 'https://git.example.42/apps/my_app/',
  vcsrepo     =&gt; 'svn',
}
</code></pre></div></div>

<p>Provide a data directory (the default DocumentRoot, for apache) from a Git repository (it requires Puppet Labs‚Äô vcsrepo module):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::dir { 'apache':
  # Prefix is a tag that defines the type of directory to use
  # Default: config. Other possible dir types: 'data', 'log', 'confd', 'lib'
  #  available according to the application
  prefix      =&gt; 'data' 
  source      =&gt; 'https://git.example.42/apps/my_app/',
  vcsrepo     =&gt; 'git',
}
</code></pre></div></div>

<p>Configure a single line in an existing file (TODO):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::line { 'redis::redis.conf::port':
  value =&gt; '1234',
}
</code></pre></div></div>

<p>Configure a fragment of a given file (TODO):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::concat { 'redis::redis.conf':
  order   =&gt; '10',
  content =&gt; 'port 1234',
}
</code></pre></div></div>

<p>Install an application and provide custom settings for internally used parameters (TODO):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp::install { 'redis':
  settings =&gt; {
    config_dir_path =&gt; '/opt/redis/conf',
    tcp_port        =&gt; '3242',
    pid_file_path   =&gt; '/opt/redis/run/redis.pid',
  },
}
</code></pre></div></div>

<h4 id="tiny-puppet-usage-on-the-command-line">Tiny Puppet usage on the Command Line</h4>

<p>The previous code samples are expected to be used in manifests, mostly in higher abstraction modules where the single components applications have to be installed and configured as needed.</p>

<p>All the logic on how to correlate and configure different applications may stay in these higher abstraction classes, which can use the tp defines to configure specific files as needed or lines inside existing files.</p>

<p>Note also that  tp  defines are relatively light, and even if in most cases they just wrap native resources like package, service and file, they are probably slimmer and less resource intensive than a dedicated module.</p>

<p>Still there‚Äôs something more that such a Tiny Puppet module can do: bring Puppet knowledge to the cli.</p>

<p>It‚Äôs an old idea of mine which I implemented with Puppi but required some extra code on Exaple42 modules for a seamless integration: with Puppet we install and configure everything, we have complete knowledge on how an application is installed on a system, and it would be useful to query and use this information directly via a command line tool.</p>

<p>Once you can do something with a single unattended command on your shell, you can do that in many different ways: inside scripts, on cron jobs, as remote command execution during a continuos delivery pipeline or an orchestrated sequence.</p>

<p>That‚Äôs why I plan to introduce a tp Puppet face that can allow the execution of simple, and powerful, commands as the ones that follow.</p>

<p>Install a specific application (TODO)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puppet tp install redis
</code></pre></div></div>

<p>Retrieve contextual info about an application (TODO). For example the relevant network connection, the output of diagnostic commands, the status of the managed application</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puppet tp info redis
</code></pre></div></div>

<p>Check if an application is running correctly (TODO)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puppet tp check redis
</code></pre></div></div>

<p>This last command, still not implemented, reflects one of the features I liked most of Puppi when used with Example42 NextGen modules: the ability to immediately check on a system if the resources provided by the installed modules deliver a working application.</p>

<p>Launch it from the shell, via Mcollective, as a step in a CI pipeline and verify immediately if your application, as configured with your own parameters, is running correctly on the provisionined system‚Ä¶ a bit simpler than writing Beaker tests, isn‚Äôt it?</p>

<p>Since <code class="highlighter-rouge">puppet tp</code> would be a face it could leverage on Puppet libraries and functions, and this may bring to some interesting interactions. For example a failing <code class="highlighter-rouge">puppet tp check</code> (eventually executed via cron) command may trigger a report message that could be used, by the report server (typically the Puppet Master) to send alarms or trigger the execution of other activities (for example a Puppet run), with an orchestration tool like MCollective.</p>

<h3 id="so-what">So what?</h3>

<p>Well, these are more or less the points behind Tiny Puppet.</p>

<p>I‚Äôm genuinely interested in knowing opinions and suggestions about them.
There are various implementation details to define and some decision on the structure of the data directory.
The repository is on <a href="https://github.com/example42/puppet-tp">GitHub</a> open for contributions.</p>

<p>Alessandro Franceschi</p>
:ET