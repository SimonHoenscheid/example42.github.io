I"C<h3 id="example42-puppet-tutorial---part-3">example42 Puppet Tutorial - Part 3</h3>

<p>This is the third post of a series of articles covering an introduction to Puppet.</p>

<p>In the <a href="https://www.example42.com/2018/04/09/puppet_tutorial_part_1/">first post</a> I started with Puppet agent installation and how to use Puppet and Facter to analyse your system. Next topics have been the introduction to the Puppet programming language (DSL), how to setup the central Puppet master and how to connect Puppet agents to the Puppet master.</p>

<p>The <a href="https://www.example42.com/2018/04/16/puppet_tutorial_part_2/">second posting</a> covered Puppet modules, code logic and variables and how to add external facts to your systems. Besides this I introduced parameters and the concept of separating code and data by using hiera.</p>

<p>This third part will explain how to make use of upstream Puppet libraries when describing your own infrastructure, how to best classify nodes and where to place the code.</p>

<p>At the last posting I will combine what I have shown and explain how to make use of the example42 <a href="https://github.com/example42/psick.git">PSICK control repository</a>, the <a href="https://github.com/example42/puppet-psick.git">PSICK module</a> and the <a href="https://github.com/example42/psick-hieradata">PSICK hieradata</a>.</p>

<ul id="markdown-toc">
  <li><a href="#example42-puppet-tutorial---part-3" id="markdown-toc-example42-puppet-tutorial---part-3">example42 Puppet Tutorial - Part 3</a>    <ul>
      <li><a href="#technical-component-library-modules" id="markdown-toc-technical-component-library-modules">Technical Component (Library) Modules</a></li>
      <li><a href="#implementation-profiles" id="markdown-toc-implementation-profiles">Implementation Profiles</a></li>
      <li><a href="#business-use-case-role" id="markdown-toc-business-use-case-role">Business Use Case Role</a></li>
      <li><a href="#node-classification" id="markdown-toc-node-classification">Node Classification</a></li>
      <li><a href="#the-puppet-control-repository" id="markdown-toc-the-puppet-control-repository">The Puppet Control Repository</a></li>
    </ul>
  </li>
</ul>

<h4 id="technical-component-library-modules">Technical Component (Library) Modules</h4>

<p>Usually we encourage you to write your own Puppet code, because this is the best way to learn Puppet DSL. But once there will be the time where you ask yourself whether you have to maintain a large code base by yourself unless you have super simple Puppet code only.
This is the time where you will rethink your Puppet usage.</p>

<p>There are many people and organisations which provide Puppet modules. Main search starting point is the <a href="https://forge.puppet.com">Puppet Forge</a>. Another search might lead you to <a href="https://github.com">GitHub</a> and here especially to <a href="https://github.com/voxpupuli">voxpupuli</a> or <a href="https://github.com/example42">example42</a>.</p>

<p>The modules which can be found at the above mentioned links are very generic, usable on many different operating systems and (hopefully) can be adopted to your specific implementation.</p>

<p>From now on we refer to the upstream developed, generic modules as <strong><em>Technical Component Modules</em></strong>. Best way is to see them like libraries for a programming language.</p>

<p>But when you search e.g. for an Apache Module you will find <a href="https://forge.puppet.com/modules?utf-8=%E2%9C%93&amp;page_size=25&amp;sort=rank&amp;q=apache">1056 matching modules</a>. So which one is the one you should use?</p>

<p>Luckily the Puppet Forge has some more information on modules. First there are supported modules. These modules are usually managed by Puppet itself and are included in the Puppet Enterprise Support Contract and are therefore a good choice.</p>

<p>Next Puppet added the “approved” flag. These are modules developed by community or organisations and had a careful review regarding supported Operating systems, Tests included and have active maintainer.</p>

<p>Other information for each module is the number of downloads and the community feedback (Quality score).</p>

<p>If you find errors or misbehaviour on Technical Component Modules, you are encouraged to collaborate with upstream development to get the issue fixed. It makes no sense to only locally fix the issue as you will loose upgradeability.</p>

<p>We recommend to mirror Technical Component Modules on your internal Git server to not rely on foreign infrastructure (network, servers, storage,…) when deploying them to your Puppet Master.</p>

<p>Technical Component Modules only manages the smallest possible set of configuration. A Tomcat Module only manages Tomcat, the required Java installation is managed by a Java Module. Apache Module configured Apache, PHP module does the same for PHP only.</p>

<h4 id="implementation-profiles">Implementation Profiles</h4>

<p>So most of the work has been made with Technical Component Module development. Now it is up to you to describe how these Modules should be implemented and adopted to your infrastructure and requirements.</p>

<p>This work is also placed in a Puppet Module but this module serves a specific need. It describes your implementation. Implementation Modules are now called <strong>Profiles</strong>.</p>

<p>A Profile is the smallest set of infrastructure artefacts.
Think of an authentication Profile which uses SSH, SSSD and PAM Technical Component Modules.</p>

<p>Now it is easy to do additional infrastructure artefacts:
Your Mail Profile uses Postfix and Clamav Modules, your Logging Profile uses rsyslog and splunk Module, your Monitoring Profile uses prometheus and grafana Module.</p>

<p>Technically a Profile is also a Module. It has a manifests path, it can have a files and templates directory.
To better visualise the different usage, it is recommended to place Profiles into a separate module path.
This can be done by configuring the environment.conf file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/environment.conf
modulepath = ./site:./modules:$basemodulepath
</code></pre></div></div>

<p>Within your environment you place Technical Component Modules in the <code class="highlighter-rouge">modules</code> directory and your profiles in a profile directory located in the <code class="highlighter-rouge">site</code> folder.</p>

<p>Differences among your platform can be placed in hiera. Usually we recommend to do lookups in profiles and to declare Technical Component Classes by specifying all required parameters.
This prevents from having hiera data with module name space.</p>

<p>Example - Puppet Profile</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/site/profile/manifests/authentication.pp
#
class profile::authentication (
  String[1]     $ldap_server,
  Array[String] $ssh_allow_groups = [],
  Boolean       $permit_root      = false,
){
  # Puppet DSL code
  class { 'ssh':
    permit_root_login       =&gt; $permit_root,
    sshd_config_allowgroups =&gt; $ssh_allow_groups,
  }
  # ...
}
</code></pre></div></div>

<p>Example - Hiera Data</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/data/stage/dev.yaml

profile::authentication::ldap_server: 'ldap.domain.tld'
profile::authentication::permit_root: true
</code></pre></div></div>

<p>Following this pattern allows you to easily identify which profile uses which data.</p>

<p>Profiles may contain:</p>

<ul>
  <li>declaration of classes and resources</li>
  <li>parameters</li>
  <li>few Puppet DSL code logic</li>
  <li>files and templates</li>
  <li>facts</li>
  <li>functions</li>
  <li>Resource ordering</li>
</ul>

<p>Profiles should <strong>not</strong> contain:</p>

<ul>
  <li>defined resource types</li>
  <li>custom types and providers</li>
  <li>Puppet data types</li>
  <li>OS specific case (this must be done in a Technical Component Module)</li>
</ul>

<h4 id="business-use-case-role">Business Use Case Role</h4>

<p>When you have many identical systems it will be error prone when you just use Profiles for node classification.
In this case you want to reconsider that any system in your infrastructure serves a specific business need. Some systems might be of value to IT only (metrics and backup server) some have a generic value to everybody (Mail and DNS server), some are used by customers (Login server and invoicing system).</p>

<p>You want to try to identify the business use case for each system. Sometimes it will be hard for IT to provide a correct name. Just head to the business owner and ask what they use the system for.
e.g. everybody knows the ‘vacation planner’, but when you ask HR they will tell you that this is the ‘HR self service portal’.</p>

<p>Each business use case is built based on profiles. We call them now <strong>Roles</strong>.</p>

<p>Roles should contain:</p>

<ul>
  <li>declaration of Profiles classes using include or contain</li>
  <li>Resource ordering</li>
</ul>

<p>Roles should <strong>not</strong> contain:</p>

<ul>
  <li>explizit resource declaration</li>
  <li>code logic</li>
  <li>self defined resource types</li>
  <li>Puppet data types</li>
  <li>types and providers</li>
  <li>facts</li>
  <li>functions</li>
  <li>parameters</li>
</ul>

<p>An example for a Role:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/site/role/manifests/ci_server.pp
#
class role::ci_server {
  contain profile::authentication
  contain profile::backup::client
  contain profile::jenkins::master

  Class['profile::authentication']
  -&gt; Class['profile::backup::client']
  -&gt; Class['profile::jenkins::master']
}
</code></pre></div></div>

<h4 id="node-classification">Node Classification</h4>

<p>Now you have all Puppet Code in place.
The master muss somehow identify what Roles should be compiled into the catalog for a specific systems. This process is called Node Classification.</p>

<p>There are three different ways on how to do node classification:</p>

<ol>
  <li>manifests based per node classification</li>
  <li>fact based node classification</li>
  <li>hiera based node classification</li>
</ol>

<p>The manifest based node classification might look like being the most simple one, but that is only true for small environments with only a few systems.</p>

<p>Just add a node declaration to your <code class="highlighter-rouge">manifests/site.pp</code> in your control repository:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/manifests/site.pp
# ...
node 'id3452276.domain.com' {
  contain role::ci_server
}
</code></pre></div></div>

<p>The name provided seems to look like a FQDN. In fact it is the common name of the nodes client SSL certificate.</p>

<p>You can also split up your node classification in multiple files and directories, located in the manifests directory:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/manifests/dev_zone.pp
# ...
node 'jenkins.dev.domain.com' {
  contain role::ci_server
}
</code></pre></div></div>

<p>The next possible solution is to make use of facts which have been placed onto a system during provisioning.
When you for example spin up a new app web server for your infrastructure you place deploy an external fact to the system:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/facter/facts.d/classification.yaml
#
application: 'webserver'
stage: 'development'
</code></pre></div></div>

<p>Now you can from Puppet code query the existence of the fact and use the fact for node classification. This reduces your node classification to just one default node:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/manifests/site.pp
# ...
node default {
  if $facts['application'] {
    contain "role::${facts['application']}"
  }
}
</code></pre></div></div>

<p>Now there is also no need to have the node mentioned. You can place the variable check and class declaration directly into your site.pp file:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/manifests/site.pp
# ...
if $facts['application'] {
  contain "role::${facts['application']}"
}
</code></pre></div></div>

<p>This solution is handy when you want to be able to reuse an existing system and let it have another role, as you only have to change the fact.
<strong>Please note that changing a systems use case is not considered best practice!</strong> Usually you want to de-provision the old system and provision a new one.</p>

<p>And then there is hiera. You can add node classifications also directly into hiera.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/data/nodes/id3046756732.domain.com.yaml
#
role: 'ci_server'
</code></pre></div></div>

<p>In your node classification you only do a lookup on the key ‘classes’ and use the value:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/code/environments/production/manifests/site.pp
# ...
$role = lookup('role', String, first, 'base')
contain "role::${role}"
</code></pre></div></div>

<h4 id="the-puppet-control-repository">The Puppet Control Repository</h4>

<p>Now you have everything together which is needed in a Puppet environment.
But how do you develop new features, how do you refactor existing code, how to test that everything is working?</p>

<p>This is where the concept of a Control Repository will help you.
A Control Repository is a GIT Repository. Different to “normal” GIT repositories the default branch will not be “master”. The Control Repository uses “production” as default branch.</p>

<p>The required modules are listed in <code class="highlighter-rouge">Puppetfile</code>. For each Module you will provide the GIT url and specify a tag or a commit which should be deployed:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Puppetfile
# ISSUES:
# activemq - f4b580461e1b9c1980f3141f0414512aa6b2a0ba -  has some new features, needs new build: 0.4.1 or higher
#
mod 'activemq',
  :git =&gt; 'ssh://git@&lt;git server&gt;:&lt;port&gt;/&lt;path&gt;/puppetlabs-activemq.git',
  :ref =&gt; 'f4b580461e1b9c1980f3141f0414512aa6b2a0ba'

mod 'ssh',
  :git =&gt; 'ssh://git@&lt;git server&gt;:&lt;port&gt;/&lt;path&gt;/ghoenycutt-ssh.git',
  :ref =&gt; 'v3.57.0'
</code></pre></div></div>

<p>Any Code development is done in a feature branch. Changes are merged with fast-forward strategy from the feature branch into the production branch.</p>

<p>But how do you deploy the Puppet code from the feature branch? How do you update production code after a merge?</p>

<p>Code deployment in this case is handled by <a href="https://github.com/puppetlabs/r10k">r10k</a>. The r10k application is installed and configured on the Puppet Master:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/opt/puppetlabs/bin/gem install r10k
</code></pre></div></div>

<p>Configuration file is located in <code class="highlighter-rouge">/etc/puppetlabs/r10k</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># /etc/puppetlabs/r10k/r10k.yaml
---
:cachedir: /opt/puppetlabs/puppet/cache/r10k
:sources:
  puppet:
    basedir: /etc/puppetlabs/code/environments
    remote: ssh://git@&lt;git server&gt;:&lt;port&gt;/&lt;path&gt;/puppet-control-repo.git
</code></pre></div></div>

<p>r10k pulls the control repository and checks for existing branches. Branch names are then converted to Puppet environment paths.
In each of the environments, r10k will parse the Puppetfile and install the mentioned modules.
This is achieved by running r10k:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/opt/puppetlabs/puppet/bin/r10k deploy environments -pv
</code></pre></div></div>

<p>The <code class="highlighter-rouge">-p</code> option enables parsing of Puppetfile and installing modules. <code class="highlighter-rouge">-v</code> enables verbose output so you see what r10k is doing.</p>

<p>From now it is up to you, whether you want to start with an empty control repository and add all required code by yourself or whether you want to adopt an existing control repository to your needs.</p>

<p>The upcoming posting will explain the concept of <a href="https://github.com/example42/psick.git">example42 PSICK Control Repository</a> and how you can easily adopt it to your infrastructure.</p>

<p>Martin Alfke</p>
:ET