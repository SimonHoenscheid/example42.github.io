I"P?<p>One of the most important tasks we face when working with Puppet is <strong>Node Classification</strong>, that is the action of assigning classes to nodes each class containing the resources we want to manage on a node.</p>

<p>I used the word “assign”, in other parts I might use the word “include”, more precisely is the method used to decide what classes, with the contained resources, have to be added to the catalog compiled, usually on the Puppet server, and applied on the client node when Puppet runs.</p>

<p>Classes are typically defined in modules and may have parameters: setting the parameter values of the classes we use on our different nodes is another other crucial Puppet activity, which is commonly done via Hiera and is worth is blog post of its own. Or a read to the <a href="https://puppet.com/docs/puppet/5.5/hiera_automatic.html#looking-up-data-with-hiera">Looking up data qith Hiera</a> documentation page, at least the first part about Automatic Lookup of Class Parameters.</p>

<p>Once we have defined what classes are  “included” in what node and how they are parametrised, we have basically done  our work with Puppet.</p>

<p>Puppet nodes classification can be done in several different ways, let’s review the most common ones with a final mention to our psick approach.</p>

<h3 id="node-statement">Node statement</h3>

<p>This is the original and still usable, even if not too much popular in these days, method.</p>

<p>We can use the <strong><a href="https://puppet.com/docs/puppet/5.5/lang_node_definitions.html">node</a></strong> statement in <code class="highlighter-rouge">manifests/site.pp</code> or other manifests in the main <code class="highlighter-rouge">manifests</code> directory of our control repo / Puppet environment. With this approach, we identify each node by its certname and declare all the resources and classes we want for it, as shown in the following code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> node 'web01.example.com' {
   include ::general
   include ::apache
 }
</code></pre></div></div>

<p>We can also use regular expressions, to group together different nodes, for example, all the nodes with name beginning with “web” can be grouped as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node /^web/ {
  include ::general
  include ::apache
}
</code></pre></div></div>

<p>In the past it was possible to use inheritance to manage nodes and groups of nodes, but this no more supported as it could lead to scoping issues with variables, when used incorrectly.</p>

<h3 id="external-node-classifier">External Node Classifier</h3>

<p>On an <a href="https://puppet.com/docs/puppet/5.5/nodes_external.html">External Node Classifier</a> (ENC), we can define the classes (and parameters) that each node should have in a totally separated tool, which can be on a system other than the puppet server.</p>

<p>To configure Puppet to use an ENC, it’s enough, on the puppet server to add lines like these to <code class="highlighter-rouge">puppet.conf</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[master]
  node_terminus = exec
  external_nodes = /usr/local/bin/enc
</code></pre></div></div>

<p>When configured to use an ENC with the <code class="highlighter-rouge">node_terminus = exec</code> option, Puppet runs the command specified via <code class="highlighter-rouge">external_nodes</code> and it passes as argument the client’s certname.</p>

<p>The executed command can do anything with any language (query a web API, a Database, check file contents) and has to return a YAML output for the given certname with contents as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
environment: production
classes:
  - general:
  - apache:
parameters:
  role: 'web'
</code></pre></div></div>

<p>Here are defined the classes to include for that node, the global parameters, which will be usable as top scope variables in Puppet code and the Puppet environment to use.</p>

<p><a href="https://puppet.com/products/puppet-enterprise">Puppet Enterprise</a>, <a href="https://www.theforeman.org">The Foreman</a>,  <a href="https://github.com/sodabrew/puppet-dashboard">Puppet Dashboard</a> and other less popular products can all work as external nodes classifiers with a Web frontend where to select what classes to include in what nodes, or group of nodes.</p>

<p>Note however that an ENC can be of any kind, and doesn’t involve the presence of a Web interface where to configure data for clients.</p>

<p>A YAML based ENC is as a script can be one that just makes a <code class="highlighter-rouge">cat</code> of a Yaml file with contents as the one shown before. Look <a href="https://github.com/example42/psick/blob/production/bin/enc_cat.sh">here</a> for such an example, which uses files in <a href="https://github.com/example42/psick/tree/production/bin/enc_cat">this directory</a>.</p>

<h3 id="ldap">LDAP</h3>

<p>Since its early years, Puppet has the possibility to integrate with <a href="https://puppet.com/docs/puppet/5.5/nodes_ldap.html">LDAP</a> and retrieve the lists of classes (referenced with the <code class="highlighter-rouge">puppetClass</code> attribute) to include in nodes, which can be managed in a ldap tree where a node can inherit the classes  set in a parent node (<code class="highlighter-rouge">parentNode</code> attribute).</p>

<p>LDAP based node classification is not common and is usually not even mentioned, but it’s a viable alternative, especially where there is a robust LDAP infrastructure which users can access and manage with any kind of graphical user interface.</p>

<p>Configuration requires some settings on the Puppet server <code class="highlighter-rouge">puppet.conf</code> as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[master]
node_terminus = ldap
ldapserver = ldap.example.com
ldapbase = ou=Hosts
ldapuser = cn=admin,ou=users,dc=example,dc=com
ldappassword = ldapuser_password
</code></pre></div></div>

<p>also we need to add Puppet’s <a href="http://github.com/puppetlabs/puppet/blob/master/ext/ldap/puppet.schema">schema</a> to the LDAP server and be sure to have, in our <code class="highlighter-rouge">manifests/site.pp</code> a default node statement like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node default {}
</code></pre></div></div>

<h3 id="hiera">hiera</h3>

<p>We can specify the list of classes to include on a node via Hiera.</p>

<p>Versions ago there was the <code class="highlighter-rouge">hiera_include</code> function, typically added in <code class="highlighter-rouge">manifests/site.pp</code> as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hiera_include('classes').
</code></pre></div></div>

<p>This function looks for the ‘classes’ key in Hiera (could be any name), which is expected to contain an array of classes to merge across hiera’s hierarchies and include in the relevant node.</p>

<p>The hiera_include, as all the other hiera_* functions, is now deprecated and can be replaced by <code class="highlighter-rouge">lookup</code>, so the above line can be replaced by:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lookup('classes',Array,'unique',[]).include
</code></pre></div></div>

<p>Which is a fancy and condensed way of writing:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$classes = lookup('classes',Array,'unique',[])
$classes.each | $class | {
  include $class
}
</code></pre></div></div>

<p>Then, we define in our hierarchy under the key named <code class="highlighter-rouge">classes</code>, what to include for each node. For example, with a YAML backend, our case would be represented with the following lines data:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
classes:
  - general
  - apache
</code></pre></div></div>

<h3 id="nodeless-classification">Nodeless Classification</h3>

<p>In our main manifest <code class="highlighter-rouge">manifests/site.pp</code> we have the code that the Puppet master alwayes parses first when compiling a catalog. Here we can place anything: declarations of resources we want on ALL the nodes, nodes statements (as in the example before), resources defaults, definition of top scope variables and so any valid Puppet code.</p>

<p>Here we can also include classes without the need to use the node statement.</p>

<p>If we write here, outside any conditional logic, something like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include general
</code></pre></div></div>

<p>The <code class="highlighter-rouge">general</code> class (which, by convention, is expected to be defined in the file <code class="highlighter-rouge">manifests/init.pp</code> of a module called <code class="highlighter-rouge">general</code>) is included on all the nodes.</p>

<p>Here we can also include classes according to whatever logic we want, eventually using variables in the class names. So, for example if we have a fact (or a parameter set via an ENC) called <code class="highlighter-rouge">$role</code> we can implement the roles and profiles pattern just by adding something like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include "role::${::role}"
</code></pre></div></div>

<p>and have in a module called <code class="highlighter-rouge">role</code> different classes named according to the <code class="highlighter-rouge">$role</code> variable values we may have.</p>

<h3 id="psick-module-classification">PSICK module Classification</h3>

<p>In example42 we like to explore new way of doing things with Puppet and refine our ideal approach to managing infrastructures with it.</p>

<p>The <a href="https://github.com/example42/puppet-psick">psick module</a> has an unique approach to nodes classification based on Hiera data, featuring:</p>

<ul>
  <li>
    <p>Usage of hashes instead of arrays to more easily allow overrides and exceptions to the list of classes to include in each nodes</p>
  </li>
  <li>
    <p>Different Hiera keys to manage classes to include on different OS (so that you don’t need to add OS specific layers in your environment’s hiera.yaml)</p>
  </li>
  <li>
    <p>Different phases of Puppet application: an optional <code class="highlighter-rouge">firstrun</code> mode, where are defined what classes to include in the very first Puppet run, and three other phases, <code class="highlighter-rouge">pre</code>, <code class="highlighter-rouge">base</code> and <code class="highlighter-rouge">profiles</code> , classes defined for them are applied in that order (so typically in <code class="highlighter-rouge">pre</code> we include classes like proxy and repo settings which are a prerequisited for the others, in <code class="highlighter-rouge">base</code> the common classes we want on all the nodes (even if we can override them via Hiera) and in <code class="highlighter-rouge">profiles</code> the typical profile classes, as in the roles and profiles pattern).</p>
  </li>
</ul>

<p>In order to use Psick classification we need to add the <code class="highlighter-rouge">psick</code> class to our nodes with whatever classification method we want and then configure everything via Hiera.</p>

<p>Then we can use the psick module (which also provides a lot of profiles for common use cases) by setting Hiera data as follows, having different keys for Linux phases:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psick::pre::linux_classes:
  repo: psick::repo

psick::base::linux_classes:
  sudo: psick::sudo
  ssh: psick::openssh::tp
  mail: postfix

psick::profiles::linux_classes:
  webserver: apache
</code></pre></div></div>

<p>and Windows ones:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psick::enable_firstrun: true
psick::firstrun::windows_classes:
  hostname: psick::hostname
  aws_sdk: psick::aws::sdk    

psick::pre::windows_classes:
  hosts: psick::hosts::resource

psick::base::windows_classes:
  features: psick::windows::features
  time: psick::time
  users: psick::users::ad

psick::profiles::windows_classes:
  webserver: iis
</code></pre></div></div>

<p>For each element of the above hashes, the element’s key name is used as a tag to allow override via Hiera, and the value is the class name to include (in the above example most of these class names are profiles defined in the same psick module, but can be classes from any module with any name).</p>

<p>So for example, given the above data in <code class="highlighter-rouge">common.yaml</code> we can override to a specific node the name of the class to use to manage ssh with a node specific Hiera yaml file with a content like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psick::base::linux_classes:
  ssh: profile::ssh::bastion
</code></pre></div></div>

<p>On the relevant node the class used to configure ssh (note that we used the <code class="highlighter-rouge">ssh</code> key, but this could be called in any way, not necessarily referring to the actual function) will a custom class called <code class="highlighter-rouge">profile::ssh::bastion</code> from our local profile module instead of the common one from psick module <code class="highlighter-rouge">psick::openssh::tp</code>.</p>

<p>We can even decide to NOT manage ssh at all on a node (or group of nodes, according to where on Hiera we make the configuration) with an entry like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>psick::base::linux_classes:
  ssh: ''
</code></pre></div></div>

<p>which overrides and nullifies the classes defined in more general Hiera layers.</p>

<p>You can read more about PSICK approach to classification on this <a href="https://www.example42.com/2018/01/15/classification_and_first_run_mode_with_psick/">blog post</a></p>

<h3 id="roles-and-profiles">Roles and profiles</h3>

<p>Strictly speaking the Roles and Profiles pattern is not a classification alternative, but a way to organise classes in a flexible and composable way.</p>

<p>In this case we just have to include a role class in a node, and this role class will itself include other classes (typically classes from a module called profile).</p>

<p>Classification of the role class itself can be done in different ways, as the ones mentioned before:</p>

<ul>
  <li>Via an <strong>ENC</strong> including the relevant role class for each of our nodes</li>
  <li>On <code class="highlighter-rouge">manifests/site.pp</code>, including the role class inside the <code class="highlighter-rouge">node</code> statements</li>
  <li>On <code class="highlighter-rouge">manifests/site.pp</code>, if we have a $role fact, with a single line like <code class="highlighter-rouge">include "role::${::role}"</code></li>
  <li>Even via the <code class="highlighter-rouge">psick</code> module, where we can reproduce the roles and profiles pattern by defining the profiles to include only on Hiera files defined in a hierarchy level which uses the $role variable (look <a href="https://github.com/example42/psick-hieradata/tree/production/data/role">here</a> for some samples)</li>
</ul>

<h3 id="conclusion">Conclusion</h3>

<p>Puppet seems complex. Puppet <strong>is</strong> complex, because it requires knowledge of many things for effective usage.</p>

<p>Still once you understand a few key concepts everything becomes clearer and the dots start to be connected.</p>

<p>One of this key concepts is classification: how we decide what classes have to be included on what nodes.</p>

<p>I hope that after this reading you have a better and clearer idea on how you can manage nodes classification in Puppet, and what approach better fits your use case.</p>

<p>Alessandro Franceschi</p>
:ET