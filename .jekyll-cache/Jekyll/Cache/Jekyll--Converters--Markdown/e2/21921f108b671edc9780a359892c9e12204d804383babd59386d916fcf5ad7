I"ô-<p>The quality of Puppet modules is constantly increasing, for each relevant application there‚Äôs a good module to manage it.</p>

<p>They may have different structures, features sets, OS coverage and naming conventions (:-I) but most of the times the better modules around do their work.</p>

<p>Still, often, also in some of the most popular modules, I desperately miss a few basic features that would allow me to use them without being forced to make a local fork.</p>

<p>Whenever we have to modify a public module to adapt it to our needs, we have a reusability failure IMHO.</p>

<p>The good news is that a few very and easy to apply principles may improve dramatically our modules‚Äô reusability without the need of a local fork.</p>

<p>They are not rocket science, just common sense and more or less established patterns. Let‚Äôs review them.</p>

<h4 id="expose-a-parameter-to-change-the-used-templates-always">Expose a parameter to change the used templates. Always.</h4>

<p>Wherever we use an erb template in our module to populate the content of a managed file, we should add a parameter that allows our users to provide their own custom template.</p>

<p>The reason is simple, in most of the cases we simply can‚Äôt provide a fitting template for the configuration needs of everyone.</p>

<p>So, whenever we have in a module something like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file { '/etc/redis/redis.conf':
  content =&gt; template('redis/redis.conf.erb'),
}
</code></pre></div></div>

<p>We can expose in the class or the define that contains this file declaration a parameter that allows customisation of the template.</p>

<p>For the above example, a quick, safe, and backwards compatible fix is as easy as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class redis (
  $config_file_template = 'redis/redis.conf.erb',
) {

  file { '/etc/redis/redis.conf':
    content =&gt; template($config_file_template),
  }
}
</code></pre></div></div>

<h4 id="expose-a-parameter-for-a-generic-configuration-hash">Expose a parameter for a generic configuration hash</h4>

<p>What and how many parameters should a module expose?</p>

<p>We may try to expose plenty of parameters to configure any possible configuration setting of our application, or we can expose only the ‚Äúmost important‚Äù ones, the ones that are more frequently changed, leaving room for ambiguity and arbitrary choices.</p>

<p>We can also expose a single parameter where users can pass an hash of custom and arbitrary data, for whatever usage they may think about.</p>

<p>Such a parameter is generally paired with the template one we have just seen.</p>

<p>Let‚Äôs just add it to our class:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class redis (
  $config_file_template = 'redis/redis.conf.erb',
  $options_hash         = {¬†},
) {

  file { '/etc/redis/redis.conf':
    content =&gt; template($config_file_template),
  }

}
</code></pre></div></div>

<p>Now our users can have (Hiera) data where they can define whatever they want:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
  redis::config_file_template: 'site/redis/redis.conf.erb'
  redis::options_hash:
    port: '12312'
    bind: '0.0.0.0'
    masterip: '10.0.42.50'
    masterport: '12350'
    slave: true
</code></pre></div></div>

<p>The template to use for redis.conf is taken from a custom local site module (so no modification is needed on the ‚Äúpublic‚Äù redis module) and in this template we can access the $options_hash variable.</p>

<p>A sample fragment of the file <code class="highlighter-rouge">$MODULEPATH/site/templates/redis/redis.conf.erb</code> might be like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port &lt;%= @options_hash['port'] %&gt;
bind &lt;%= @options_hash['bind'] %&gt;
&lt;% if @options_hash['slave'] == true -%&gt;
slaveof &lt;%= @options_hash['masterip'] %&gt; &lt;%= @options_hash['masterport'] %&gt;
&lt;% end -%&gt;
</code></pre></div></div>

<p>Users can actually provide any kind of data in such an hash, and use it in their templates as preferred. They can use it for application‚Äôs configuration options, to manage triggers with booleans or to pursue any other purpose that fits their needs.</p>

<p>Is such a generic hash a catch all solution that might replace all or most parameters used only to populate the contents of our templates?</p>

<p>Well, eventually.</p>

<p>Let‚Äôs look at the next step.</p>

<h4 id="provide-defaults-for-the-options_hash">Provide defaults for the options_hash</h4>

<p>I may understand the eyebrow of the module author reading this and wondering how to provide a working and useful setup out of the box with just a generic hash which is empty by default.</p>

<p>Actually what‚Äôs empty can be filled with default values, exactly like the default values we place in parameters.</p>

<p>We can, for example, set default values in this way:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class redis (
  $config_file_template = 'redis/redis.conf.erb',
  $options_hash         = {¬†},
) {

# Default configuration values  
  $options_defaults = {
    port     =&gt; '6379',
    bind     =&gt; $::ipaddress,
    slave    =&gt; false,
    timeout  =&gt; '0',
  }

  # We use the merge function from stdlib to override the defaults with users' values
  $options=merge($options_defaults, $options_hash)

}
</code></pre></div></div>

<p>Now we can provide in our module a default configuration template that is highly customisable via the <code class="highlighter-rouge">$options_hash</code> parameter, with the extra benefit of providing good sample reference for users‚Äô custom templates.</p>

<p>Our module‚Äôs <code class="highlighter-rouge">$MODULEPATH/redis/templates/redis.conf.erb</code> should, obviously, use the computed <code class="highlighter-rouge">$options</code> variable which is the result of the merging of users‚Äô data with our defaults:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>port &lt;%= @options['port'] %&gt;
bind &lt;%= @options['bind'] %&gt;
&lt;% if @options['slave'] == true -%&gt;
slaveof &lt;%= @options['masterip'] %&gt; &lt;%= @options['masterport'] %&gt;
&lt;% end -%&gt;
</code></pre></div></div>

<p>Now we have the best of two worlds:</p>

<ul>
  <li>
    <p>Very few parameters (two) are enough to set any configuration value for the managed application</p>
  </li>
  <li>
    <p>In our modules we can set default values that are used to provide sane and working configurations out of the box</p>
  </li>
  <li>
    <p>Module‚Äôs users can manage any configuration element in their (Hiera) data. The level of detail is up to users and their needs.</p>
  </li>
</ul>

<p>Up to now we have seen how we can improve users‚Äô customisation of the content of the managed files.</p>

<p>Let‚Äôs give a look to a final hint that can literally save our modules‚Äô integrity (in terms of possibility to be used without changes) in many situations.</p>

<h4 id="place-extra-resources-in-dedicated-sub-classes-allow-users-to-change-them">Place extra resources in dedicated sub classes. Allow users to change them.</h4>

<p>A few months ago I expressed my <a href="http://www.example42.com/2014/05/31/rethinking-modules-part-1/">opinions</a> on the common ambiguity we currently have with Puppet modules about what they should and should not do.</p>

<p>This is basically due to a not clear distinction we make in application component modules, which are expected to be the single responsibility point to manage that application, and higher abstraction modules, like profiles and <a href="https://github.com/alvagante/puppet-stack_logstash/blob/master/manifests/init.pp">stacks</a> (Stacks are an approach to higher level modules I started to use as an alternative to profiles).</p>

<p>What should a wordpress module do? Install only the wordpress files? Configure the webserver? Configure the backend database?</p>

<p>If we consider it a component module it should just download the wordpress code and eventually manage its configuration file. If we want to work at an higher level, it should configure the web frontend, the database credentials and make everything work out of the box.</p>

<p>This is the first thing that users expect from a module.</p>

<p>The second one is the ability to adapt the module to custom needs.</p>

<p>Often, authors, place resources that refer to some external application, in a dedicated subclass.</p>

<p>For example <code class="highlighter-rouge">wordpress::apache</code> might be used to configure apache as frontend, alternative to a <code class="highlighter-rouge">wordpress::nginx</code> or whatever. In these cases it‚Äôs generally available a parameter that allows the choice of the webserver to use.</p>

<p>That‚Äôs fine but I‚Äôd go further. For every subclass of a module, that groups resources somehow related to other modules, there should be a parameter that allows users to provide a custom version of that class.</p>

<p>Most of the modules dependencies conflicts can be solved with such an approach.</p>

<p>Let‚Äôs see an example with something as easy as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class wordpress (
  $webserver_class = '::wordpress::apache',
) {

  if $webserver_class {
    include $webserver_class
  }
}
</code></pre></div></div>

<p>Small note with Puppet 4 the above code would not work as expected if we set an empty string as value for <code class="highlighter-rouge">$webserver_class</code>, a possible alternative could be something like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if $webserver_class
and $webserver_class != '' {
  include $webserver_class
}
</code></pre></div></div>

<p>If our users want to use a different implementation of Apache (they may use a different, not compatible, module) or a different webserver, they can simply provide the name of the class to use with data like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
  wordpress::webserver_class: '::site::wordpress::apache'
</code></pre></div></div>

<p>and define this class in the own site module, so have the file <code class="highlighter-rouge">$MODULEPATH/site/manifests/wordpress/apache.pp</code> with a content like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ::site::wordpress::apache {
  # Anything needed to configure Apache as desired  
}
</code></pre></div></div>

<p>This approach can be followed for other cases, for example, if we need to configure additional repositories to manage the installation of packages, we can con confine them in a dedicated class, or if we want to provide automatic firewalling or monitoring features with the module, we might place them in dedicated classes that allow our users to manage these features within their infrastructure.</p>

<p>I bet you have not read anything really new to you in this post, still there a lot of modules from expert authors that don‚Äôt follow these simple patterns which are not expensive and intrusive (excluding the third point, which is somehow more opinionated an questionable).</p>

<p>So, if you write and publish public Puppet modules, do yourself, your users, and me a favour, embrace these suggestions, we will have all a better Puppet life.</p>

<p>Alessandro Franceschi</p>
:ET