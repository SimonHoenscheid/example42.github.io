I"–<p>Welcome to part 4 of a series of posts on what is essential to know about Facter: <strong>trusted facts</strong> and their very particular nature.</p>

<p>But before beginning, if you missed something, here are the previous posts:</p>
<ul>
  <li><a href="https://www.example42.com/2018/05/28/what-you-need-to-know-about-puppet-facts-part-1-core_facts/">Part 1 - Facter and core facts</a></li>
  <li><a href="https://www.example42.com/2018/06/04/what-you-need-to-know-about-puppet-facts-part-2-custom_facts/">Part 2 - Custom facts</a></li>
  <li><a href="https://www.example42.com/2018/06/11/what-you-need-to-know-about-puppet-facts-part-3-external_facts/">Part 3 - External facts</a></li>
</ul>

<h3 id="trusted-facts-are-certificates-extensions-attributes">Trusted facts are certificateâ€™s extensions attributes</h3>

<p>We call trusted facts what are, more precisely, <a href="https://puppet.com/docs/puppet/5.3/ssl_attributes_extensions.html">extensions</a> to the Puppet agent x509 certificates, used in all the https communications with the server.</p>

<p>Trusted facts <strong>must</strong> be set before Puppet is executed the first time, and once set they canâ€™t be changed (unless the Puppet client certificate is removed recreated).</p>

<p>This is done by editing the file <code class="highlighter-rouge">csr_attributes.yaml</code> in the <code class="highlighter-rouge">confdir</code> (so by default itâ€™s <code class="highlighter-rouge">/etc/puppetlabs/puppet/csr_attributes.yaml</code>) where, in valid yaml format, we can set:</p>

<ul>
  <li>
    <p><strong>custom_attributes</strong>, key values that are added to the CSR but wonâ€™t appear in the certificate, once signed.
They are typically used for managing <a href="https://puppet.com/docs/puppet/5.3/ssl_autosign.html">nodesâ€™ auto sign</a></p>
  </li>
  <li>
    <p><strong>extension_requests</strong>, key values which are added to the CSR and in the generated certificate. These are what we call <strong>trusted facts</strong> in Puppet world.</p>
  </li>
</ul>

<p>A sample <code class="highlighter-rouge">/etc/puppetlabs/puppet/csr_attributes.yaml</code> can look like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---
custom_attributes:
  1.2.840.113549.1.9.7: 342thbjkt82094y0uthhor289jnqthpc2290  
extension_requests:
  pp_role: 'ci'
  pp_zone: 'lab'
  pp_environment: 'devel'
  pp_datacenter: 'us1'
  pp_application: 'jenkins'
</code></pre></div></div>

<h3 id="the-trusted-hash">The $trusted hash</h3>

<p>In Puppet we have an handy <code class="highlighter-rouge">$trusted</code> variable, an hash containing information about the client certificate with the following keys:</p>

<ul>
  <li><code class="highlighter-rouge">authenticated</code> â€” if the catalog request was authenticated (remote, local, false)</li>
  <li><code class="highlighter-rouge">certname</code> â€” the nodeâ€™s certificate name</li>
  <li><code class="highlighter-rouge">domain</code> â€” the nodeâ€™s domain, as derived from its validated certificate name.</li>
  <li><code class="highlighter-rouge">extensions</code> â€” the hash containing any custom extensions we have set in <code class="highlighter-rouge">csr_attributes.yaml</code>. Keys here are the extensions OIDs, or, if they are registered extensions, their relevant short names.</li>
</ul>

<p>Thereâ€™s already a list of Puppet registered <a href="https://puppet.com/docs/puppet/5.3/ssl_attributes_extensions.html#puppet-specific-registered-ids">ID extensions</a>, and itâ€™s possible to add custom IDs to map by editing the <a href="https://puppet.com/docs/puppet/5.3/config_file_oid_map.html">custom_trusted_oid_mapping.yaml</a> file.</p>

<h3 id="use-cases">Use cases</h3>

<p>So, we can access our trusted facts with <code class="highlighter-rouge">$trusted[extensions][&lt;EXTENSION OID&gt;]</code>, the above sample <code class="highlighter-rouge">csr_attributes.yaml</code> file would generate a <code class="highlighter-rouge">$trusted</code> variable as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  'authenticated' =&gt; 'remote',
  'certname'      =&gt; 'jenkins.lab.psick.io',
  'domain'        =&gt; 'lab.psick.io',
  'extensions'    =&gt; {
                      'pp_application' =&gt; 'jenkins',
                      'pp_datacenter' =&gt; 'us1',
                      'pp_environment' =&gt; 'devel',
                      'pp_role' =&gt; 'ci',
                      'pp_zone' =&gt; 'lab',
                      '1.3.6.1.4.1.34380.1.2.1' =&gt; 'ssl-termination'
                   },
  'hostname'      =&gt; 'jenkins'
}
</code></pre></div></div>

<p>We can directly refer to trusted facts in our Hiera hierarchies:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - "nodes/%{trusted.certname}.yaml"
  - "roles/%{trusted.extensions.pp_role}.yaml"
  - "zones/%{trusted.extensions.pp_zone}.yaml"
</code></pre></div></div>

<p>Or in our Puppet code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if $trusted['extensions']['pp_role'] {
  $role = $trusted['extensions']['pp_role']
}
if $trusted['extensions']['pp_zone'] {
  $zone = $trusted['extensions']['pp_zone']
}
</code></pre></div></div>

<p>If we had the above variables set at top scope, in a place like <code class="highlighter-rouge">manifests/site.pp</code> we could have an hierarchy equivalent to the previous example, which looks like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- "nodes/%{trusted.certname}.yaml"
- "roles/%{::role}.yaml"
- "zones/%{::zone}.yaml"
</code></pre></div></div>

<h3 id="conclusions">Conclusions</h3>

<p>We have seen that trusted facts are <em>hardcoded</em> in the Puppet client certificate, that can be set by editing the <code class="highlighter-rouge">csr_attributes.yaml</code> file before launching Puppet the very first time on a node.</p>

<p>They canâ€™t be altered, unless the client ssl certificate is cleaned and regenerated with updated attributes, so we can decide to use them or not according to our use cases.</p>

<p>If we decide to use them in our Hiera hierarchies we need a way to automate the provisioning of different nodes with different trusted facts.</p>

<p>With this approach we can decide to use such custom facts to configure and classify our nodes entirely via Hiera.</p>

<p>The same can be achieved with normal custom or external facts, which have the benefit or defect of being more easily changeable during a nodeâ€™ lifetime.</p>

<p>As usual different approaches are possible, according to our needs, whatâ€™s essential is to know possible alternatives and available options.</p>

<p>Alessandro Franceschi</p>
:ET