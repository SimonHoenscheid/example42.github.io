I",<p>We have talked about Tiny Puppet in this blog more than 3 years ago when introducing the example42 tp module and then again at release 1.0:</p>

<ul>
  <li><a href="https://www.example42.com/2015/01/02/introducing-tiny-puppet/">Introducing Tiny Puppet</a></li>
  <li><a href="https://www.example42.com/2015/10/26/preparing-for-tp-1/">Preparing for Tiny Puppet 1.0</a></li>
  <li><a href="https://www.example42.com/2015/11/18/tp-1-release/">Tiny Puppet 1.0</a></li>
</ul>

<p>More recently, we had a Tip of the Week on using the tp command from the cli:</p>

<ul>
  <li><a href="https://www.example42.com/2018/07/23/a-few-steps-to-tiny-puppet-command-line/">Tip of the Week 82 - A few steps to Tiny Puppet on the command line</a></li>
</ul>

<p>I think it’s time for some updates on Tiny Puppet given that we are at version 2.3.</p>

<p>The module is stable, solid, used in several productions, it provides:</p>

<ul>
  <li>
    <p>The user defined types <code class="highlighter-rouge">tp::install</code>, <code class="highlighter-rouge">tp::conf</code>, <code class="highlighter-rouge">tp::dir</code> to manage any <strong>(*)</strong> application</p>
  </li>
  <li>
    <p>The ruby command <code class="highlighter-rouge">tp</code> with actions like <code class="highlighter-rouge">tp install</code>, <code class="highlighter-rouge">tp test</code>, <code class="highlighter-rouge">tp log</code> to check the status of the applications installed via tp</p>
  </li>
</ul>

<h4 id="-any-application">(*) Any application</h4>

<p>The promise of installing any application (and by this we mean, package) on any <strong>(**)</strong> OS where Puppet can run is potentially matched.</p>

<p>The difference between potential and real is a matter or more or less present and correct tiny data.</p>

<p>Up to a few days ago the <em>any</em> was related to any application for which there’s <a href="https://github.com/example42/tinydata/tree/master/data">tinydaya</a>, now, since <a href="https://github.com/example42/puppet-tp/commit/c764b7b60727110518c8b3db0cf61aad0aaeff11">version 2.3.0</a>, tp install defaults to the given title, if a package with that name is installable it tries to install it on the underlying (**) OS.</p>

<h4 id="-any-os">(**) Any OS</h4>

<p>By <strong>Any OS</strong> we mean any OS where Puppet can run.</p>

<p>With <code class="highlighter-rouge">tp::install</code> (<code class="highlighter-rouge">tp install</code> on cli) we can install any application, even if no tinydata is present, if there’s usable tinydata we can configure it with <code class="highlighter-rouge">tp::conf</code> and <code class="highlighter-rouge">tp::dir</code>.</p>

<p>On Windows and MacOS respectively Chocolatey and Homebrew are used as default package provider and they are a prerequisite to install anything via tp.</p>

<h3 id="usage-on-the-cli">Usage on the cli</h3>

<p>You can install tp as a normal module, it depends on puppetlabs-stdlib and example42-tinydata:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puppet module install example42-tp
</code></pre></div></div>

<p>On Mac you need Brew installed and a valid homebrew module with the homonimous package provider:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puppet module install thekevjames-homebrew
puppet apply -e "class { homebrew: user =&gt; $local_user }"
</code></pre></div></div>

<p>On Windows you need chocolatey installed:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puppet module install puppetlabs-chocolatey
puppet apply -e "include chocolately"
</code></pre></div></div>

<p>Then, whatever the OS we can install locally the tp command with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>puppet tp setup
</code></pre></div></div>

<p>Now you can try to install anything.</p>

<p>On Linux try with packages like (if tinydata is present also custom repos are created):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp install docker
tp install elasticsearch
tp install apache
</code></pre></div></div>

<p>On Mac install anything <a href="https://brew.sh/">brew</a> can install, also via cask:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp install opera
tp install dropdox ...
</code></pre></div></div>

<p>Usage from cli under windows is Work In Progress.</p>

<h3 id="usage-in-manifests">Usage in manifests</h3>

<p>The tp command might be nice to play around and test the status of apps managed via tp, but it’s inside Puppet manifests where the tp defines can give real help in configuring our applications.</p>

<h4 id="the-tp-defines">The tp defines</h4>

<p>In your classes, typically in your profiles for specific applications you can manage the package, service, configuration files triple with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Manage package (and relevant repos if needed) and service
tp::install { 'openssh': }

# Manage main configuration file
# (File content can be managed with different params: content, template, source, epp...)
tp::conf { 'openssh':
  content =&gt; $sshd_content,
}

# Manage other configuration file (in main configuration directory)
tp::conf { 'openssh::ssh_config':
  content =&gt; $ssh_content,
}
</code></pre></div></div>

<p>tp takes care of managing dependencies and using the right names and paths for the underlying OS.</p>

<h4 id="the-tp-class">The tp class</h4>

<p>In order to install the tp command on a node, it’s enough to:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include tp
</code></pre></div></div>

<p>The tp class is needed and used only to install the tp command eventually and as entrypoint for hiera data for hashes of tp resources.</p>

<p>In this way, for example, you can define what applications to install with data like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># We can define an array or an hash of tp installs:
tp::install_hash:
  - opera
  - dropbox

# Similarly we can define hashes and things to do with tp install and conf:
tp::install_hash:
  elasticsearch:
    auto_repo: false
  logstash: {}

# A bunch of tp::conf resources:
tp::conf_hash:
  elasticsearch:
    template: profile/elasticsearch/elasticsearch.yml
    options_hash:
      cluster.name: el-1
      index.number_of_shards: 2

  logstash::syslog:
    source: puppet:///modules/logstash/syslog

  logstash::my_app:
    source: puppet:///modules/logstash/my_app
</code></pre></div></div>

<p>We don’t actually recommend to use the <code class="highlighter-rouge">tp</code> namespace for using tp, it’s more handy to use tp defines in profiles, as needed and when needed. If you don’t want to install the tp command you can skip the inclusion of the tp class, the other defines can work the same.</p>

<h4 id="custom-templates-and-variables">Custom templates and variables</h4>

<p>When using tp::conf to manage the content of a configuration file, we have at disposal, and can interpolate in our epp or erb templates, two very useful variables:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">$settings</code> is an hash with the result of the <code class="highlighter-rouge">tp_lookup</code> function, which for the given app tries to get usable tinydata. This is useful to manage in the same template cross OS differences due to file paths and names.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">$options</code> or <code class="highlighter-rouge">$options_hash</code> is currently just the content of the <code class="highlighter-rouge">options_hash</code> parameter passed to <code class="highlighter-rouge">tp::conf</code>. You can do with it whatever you want, according to the configured application.</p>
  </li>
</ul>

<p>So, your erb template can have contents as in the following fragments from this <a href="https://github.com/example42/puppet-psick/blob/master/templates/mongo/mongod.conf.erb">erb template</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>storage:
  dbPath: &lt;%= @settings['data_dir_path'] %&gt;

net:
  port: &lt;%= @settings['tcp_port'] %&gt;
  bindIp: &lt;%= @options['bindIp'] %&gt;
</code></pre></div></div>

<p>To have an idea of the available settings, give a look to the <a href="https://github.com/example42/puppet-tp/blob/master/types/settings.pp">tp::settings Data type</a>.</p>

<h4 id="generic-templates-for-standard-file-formats">Generic templates for standard file formats</h4>

<p>If we like the idea of having all our configurations as (hiera) data, we can use <code class="highlighter-rouge">tp conf</code> to manage configurations using generic templates for standard file formats, <a href="https://github.com/example42/puppet-psick/tree/master/templates/generic">like these</a> from the psick module.</p>

<p>On real life a quick profile to manage (with good hope to work on different OS) redis can looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class profile::redis (
  String $ensure   = present,
  Hash $options    = {},
  String $template = 'psick/generic/spaced.erb',
) {

  tp::install { 'redis':
    ensure =&gt; $ensure,
  }

  tp::conf { 'redis':
    ensure       =&gt; $ensure,
    template     =&gt; $template,
    options_hash =&gt; $options,
  }
}
</code></pre></div></div>

<p>With Hiera data as easy as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>profile::redis::options:
  slaveof: '127.0.0.1 6380'
  port: 6380
</code></pre></div></div>

<h3 id="so-is-tp-for-me">So is tp for me?</h3>

<p>It depends on what you need and what you know.</p>

<p>Tiny Puppet manages packages, services, repo configurations, and files whose content is entirely up to you. It doesn’t manage any application specific resource.</p>

<p>If you know how to configure your application, want a quick way (probably the quickest) to manage it with Puppet, and know at least Puppet basics, tp is for you.</p>

<p>When tp (and some DIY code) can be better than using a dedicated module from the Forge?</p>

<ul>
  <li>When don’t want to spent time testing a new module, add its dependencies, hoping it does all what you need</li>
  <li>When at the end there’s just to manage packages, services and files</li>
  <li>When you know exactly how our configuration files must be and want to control how they are generated (from static sources or dynamic templates with custom <code class="highlighter-rouge">$options</code> and os related <code class="highlighter-rouge">$settings</code>).</li>
  <li>When you don’t have to manage application specific resources, which are present in a dedicated module</li>
  <li>When you don’t have to manage complex setups for which a good dedicated module would deliver faster results</li>
</ul>

<p>Is it for you?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tp install fortune
</code></pre></div></div>

<p>Alessandro Franceschi</p>
:ET